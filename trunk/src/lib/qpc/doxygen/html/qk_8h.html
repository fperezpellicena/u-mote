<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: qk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qk.h File Reference</div>  </div>
</div>
<div class="contents">

<p>QK/C platform-independent public interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qequeue_8h_source.html">qequeue.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qmpool_8h_source.html">qmpool.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qpset_8h_source.html">qpset.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qs__port_8h_source.html">qs_port.h</a>&quot;</code><br/>
</div>
<p><a href="qk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#aee19c1d6e860d59dda6e539852b99dbe">QF_EQUEUE_TYPE</a>&#160;&#160;&#160;<a class="el" href="struct_q_e_queue.html">QEQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the event queue used for the active objects.  <a href="#aee19c1d6e860d59dda6e539852b99dbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a7afba9d8bef1f7eab181e7fb3f74eb5e">QF_OS_OBJECT_TYPE</a>&#160;&#160;&#160;<a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the OS-Object used for blocking the native QF event queue when the queue is empty.  <a href="#a7afba9d8bef1f7eab181e7fb3f74eb5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae5bd9d2bd80006cdbcd21d2acdb91d86">QF_THREAD_TYPE</a>&#160;&#160;&#160;void *</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the thread handle used for the active objects.  <a href="#ae5bd9d2bd80006cdbcd21d2acdb91d86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae2426ed9b8543cbbccde98023d7773a7">QACTIVE_EQUEUE_WAIT_</a>(me_)&#160;&#160;&#160;Q_ASSERT((me_)-&gt;eQueue.frontEvt != (<a class="el" href="struct_q_event.html">QEvent</a> *)0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should block the calling task when the QF native queue is empty.  <a href="#ae2426ed9b8543cbbccde98023d7773a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ad4ad4a29e36b9ad8e2aff0e7074c2a68">QACTIVE_EQUEUE_SIGNAL_</a>(me_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should signal the active object task that an event has just arrived.  <a href="#ad4ad4a29e36b9ad8e2aff0e7074c2a68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a61cb9dfde96112710d74f08620875427">QACTIVE_EQUEUE_ONEMPTY_</a>(me_)&#160;&#160;&#160;QPSet64_remove(&amp;<a class="el" href="qk_8c.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a>, (me_)-&gt;prio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining the action QF should take when the native QF event queue becomes empty.  <a href="#a61cb9dfde96112710d74f08620875427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a>&#160;&#160;&#160;<a class="el" href="struct_q_m_pool.html">QMPool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the event pool used in this QF port.  <a href="#ab786be96ee118929bfb4dcd51d3acce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#af536ec576d2f03b68bcf38ca0c8b918d">QF_EPOOL_INIT_</a>(p_, poolSto_, poolSize_, evtSize_)&#160;&#160;&#160;QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining the event pool initialization.  <a href="#af536ec576d2f03b68bcf38ca0c8b918d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a920e9b4f47e69079a12bf79a3c43a058">QF_EPOOL_EVENT_SIZE_</a>(p_)&#160;&#160;&#160;((p_).blockSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should obtain the event pool block-size.  <a href="#a920e9b4f47e69079a12bf79a3c43a058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#abb96d6c572a8d24921a1aa2cbddfea8c">QF_EPOOL_GET_</a>(p_, e_)&#160;&#160;&#160;((e_) = (<a class="el" href="struct_q_event.html">QEvent</a> *)QMPool_get(&amp;(p_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should obtain an event <em>e_</em> from the event pool <em>p_</em>.  <a href="#abb96d6c572a8d24921a1aa2cbddfea8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ac34ffaba95ab38473684fdfeaef17d9a">QF_EPOOL_PUT_</a>(p_, e_)&#160;&#160;&#160;(QMPool_put(&amp;(p_), (e_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should return an event <em>e_</em> to the event pool <em>p_</em>.  <a href="#ac34ffaba95ab38473684fdfeaef17d9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a7076e6697a723fef583044ca5c2efde2">QK_SCHEDULE_</a>()&#160;&#160;&#160;QK_schedule_(intLockKey_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal macro for invoking QK scheduler with interrupts locked.  <a href="#a7076e6697a723fef583044ca5c2efde2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK Mutex type.  <a href="#a13b8c3b1b8a65b6e521505922f643104"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK initialization.  <a href="#ae1fa4705c311e29699a0164a20362bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK idle callback (customized in BSPs for QK)  <a href="#a667daad24b172e782fe4e2b5b06fbf61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#adb582ced35db744615453884461a03e0">QK_getVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current QK version number string  <a href="#adb582ced35db744615453884461a03e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a1c0552f5268496a3fba67424fe9accb0">QK_getPortVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QK-port version.  <a href="#a1c0552f5268496a3fba67424fe9accb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2">QK_mutexLock</a> (<a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> prioCeiling)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK priority-ceiling mutex lock.  <a href="#a02a27011a5aa955b140cd749b64b16e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a">QK_mutexUnlock</a> (<a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a> mutex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK priority-ceiling mutex unlock.  <a href="#a9f4ddf313bcfd3cac43225f2a35e278a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a7cebcd790e3028f59e577238cfb71af2">QK_schedule_</a> (QF_INT_KEY_TYPE intLockKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The QK scheduler.  <a href="#a7cebcd790e3028f59e577238cfb71af2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a43706de173a29dc03950d3647eb41eb4">QK_scheduleExt_</a> (QF_INT_KEY_TYPE intLockKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The QK extended scheduler for interrupt context.  <a href="#a43706de173a29dc03950d3647eb41eb4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_p_set64.html">QPSet64</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a81b2832f194ed3d09803c8a4e86a1a23">QK_currPrio_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a2c90cb8ede2a3fa89616f23b7df258de">QK_intNest_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>QK/C platform-independent public interface. </p>
<p>This header file must be included directly or indirectly in all modules (*.c files) that use QK/C. </p>

<p>Definition in file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a61cb9dfde96112710d74f08620875427"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_ONEMPTY_" ref="a61cb9dfde96112710d74f08620875427" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_EQUEUE_ONEMPTY_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;QPSet64_remove(&amp;<a class="el" href="qk_8c.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a>, (me_)-&gt;prio)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining the action QF should take when the native QF event queue becomes empty. </p>
<p>The macro is necessary only when the native QF event queue is used. The signaling of task involves unblocking the task if it is blocked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QACTIVE_EQUEUE_ONEMPTY_ is called from a critical section. It should not leave the critical section.</dd>
<dd>
This is just an example of QACTIVE_EQUEUE_ONEMPTY_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00152">152</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ad4a29e36b9ad8e2aff0e7074c2a68"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_SIGNAL_" ref="ad4ad4a29e36b9ad8e2aff0e7074c2a68" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_EQUEUE_SIGNAL_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="qpset_8h.html#aebc824af496448fd68605070404d7c9d" title="insert element n_ into the set me_, n_= 1..64">QPSet64_insert</a>(&amp;<a class="code" href="qk_8h.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a>, (me_)-&gt;prio); \
        <span class="keywordflow">if</span> (<a class="code" href="qk_8h.html#a2c90cb8ede2a3fa89616f23b7df258de">QK_intNest_</a> == (<a class="code" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>)0) { \
            <a class="code" href="qk_8h.html#a7076e6697a723fef583044ca5c2efde2" title="This is an internal macro for invoking QK scheduler with interrupts locked.">QK_SCHEDULE_</a>(); \
        } \
        <span class="keywordflow">else</span> ((<span class="keywordtype">void</span>)0)
</pre></div>
<p>Platform-dependent macro defining how QF should signal the active object task that an event has just arrived. </p>
<p>The macro is necessary only when the native QF event queue is used. The signaling of task involves unblocking the task if it is blocked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QACTIVE_EQUEUE_SIGNAL_ is called from a critical section. It might leave the critical section internally, but must restore the critical section before exiting to the caller.</dd>
<dd>
This is just an example of QACTIVE_EQUEUE_SIGNAL_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00132">132</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__fifo_8c_source.html#l00046">QActive_postFIFO()</a>, and <a class="el" href="qa__lifo_8c_source.html#l00043">QActive_postLIFO()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2426ed9b8543cbbccde98023d7773a7"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_WAIT_" ref="ae2426ed9b8543cbbccde98023d7773a7" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_EQUEUE_WAIT_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;Q_ASSERT((me_)-&gt;eQueue.frontEvt != (<a class="el" href="struct_q_event.html">QEvent</a> *)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should block the calling task when the QF native queue is empty. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QACTIVE_EQUEUE_WAIT_ for the QK-port of QF. QK never activates a task that has no events to process, so in this case the macro asserts that the queue is not empty. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00104">104</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>.</p>

</div>
</div>
<a class="anchor" id="a920e9b4f47e69079a12bf79a3c43a058"></a><!-- doxytag: member="qk.h::QF_EPOOL_EVENT_SIZE_" ref="a920e9b4f47e69079a12bf79a3c43a058" args="(p_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_EVENT_SIZE_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_</td><td>)</td>
          <td>&#160;&#160;&#160;((p_).blockSize)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should obtain the event pool block-size. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_EVENT_SIZE_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00184">184</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__new_8c_source.html#l00040">QF_new_()</a>, and <a class="el" href="qf__pool_8c_source.html#l00044">QF_poolInit()</a>.</p>

</div>
</div>
<a class="anchor" id="abb96d6c572a8d24921a1aa2cbddfea8c"></a><!-- doxytag: member="qk.h::QF_EPOOL_GET_" ref="abb96d6c572a8d24921a1aa2cbddfea8c" args="(p_, e_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_GET_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((e_) = (<a class="el" href="struct_q_event.html">QEvent</a> *)QMPool_get(&amp;(p_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should obtain an event <em>e_</em> from the event pool <em>p_</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_GET_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00193">193</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__new_8c_source.html#l00040">QF_new_()</a>.</p>

</div>
</div>
<a class="anchor" id="af536ec576d2f03b68bcf38ca0c8b918d"></a><!-- doxytag: member="qk.h::QF_EPOOL_INIT_" ref="af536ec576d2f03b68bcf38ca0c8b918d" args="(p_, poolSto_, poolSize_, evtSize_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_INIT_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">poolSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">poolSize_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtSize_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining the event pool initialization. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_INIT_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00174">174</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__pool_8c_source.html#l00044">QF_poolInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ac34ffaba95ab38473684fdfeaef17d9a"></a><!-- doxytag: member="qk.h::QF_EPOOL_PUT_" ref="ac34ffaba95ab38473684fdfeaef17d9a" args="(p_, e_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_PUT_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(QMPool_put(&amp;(p_), (e_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should return an event <em>e_</em> to the event pool <em>p_</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_PUT_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00202">202</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>.</p>

</div>
</div>
<a class="anchor" id="ab786be96ee118929bfb4dcd51d3acce5"></a><!-- doxytag: member="qk.h::QF_EPOOL_TYPE_" ref="ab786be96ee118929bfb4dcd51d3acce5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_TYPE_&#160;&#160;&#160;<a class="el" href="struct_q_m_pool.html">QMPool</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the event pool used in this QF port. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of the macro definition. Typically, you need to define it in the specific QF port file (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>). In case of QK, which always depends on the native QF memory pool, this macro is defined at the level of the platform-independent interface <a class="el" href="qk_8h.html" title="QK/C platform-independent public interface.">qk.h</a>. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00166">166</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee19c1d6e860d59dda6e539852b99dbe"></a><!-- doxytag: member="qk.h::QF_EQUEUE_TYPE" ref="aee19c1d6e860d59dda6e539852b99dbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EQUEUE_TYPE&#160;&#160;&#160;<a class="el" href="struct_q_e_queue.html">QEQueue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the event queue used for the active objects. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of the macro definition. Typically, you need to define it in the specific QF port file (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>). In case of QK, which always depends on the native QF queue, this macro is defined at the level of the platform-independent interface <a class="el" href="qk_8h.html" title="QK/C platform-independent public interface.">qk.h</a>. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00055">55</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7afba9d8bef1f7eab181e7fb3f74eb5e"></a><!-- doxytag: member="qk.h::QF_OS_OBJECT_TYPE" ref="a7afba9d8bef1f7eab181e7fb3f74eb5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_OS_OBJECT_TYPE&#160;&#160;&#160;<a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the OS-Object used for blocking the native QF event queue when the queue is empty. </p>
<p>In QK, the OS object is used to hold the per-thread flags, which might be used, for example, to rembember the thread attributes (e.g., if the thread uses a floating point co-processor). The OS object value is set on per-thread basis in <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>. Later, the extended context switch macros (<a class="el" href="qk__port_8h.html#a8dc2ef090cbfdb8068e02be7af74a7a7" title="Define the method for saving the extended context (e.g., the context of a floating-point co-processor...">QK_EXT_SAVE()</a> and <a class="el" href="qk__port_8h.html#a7300efd5716c71f33e1a0a17ac4a95ed" title="Define the method for restoring the extended context (e.g., the context of a floating-point co-proces...">QK_EXT_RESTORE()</a>) might use the per-thread flags to determine what kind of extended context switch this particular thread needs (e.g., the thread might not be using the coprocessor or might be using a different one). </p>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00070">70</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5bd9d2bd80006cdbcd21d2acdb91d86"></a><!-- doxytag: member="qk.h::QF_THREAD_TYPE" ref="ae5bd9d2bd80006cdbcd21d2acdb91d86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_THREAD_TYPE&#160;&#160;&#160;void *</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the thread handle used for the active objects. </p>
<p>The thread type in QK is the pointer to the thread-local storage (TLS). This thread-local storage can be set on per-thread basis in <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>. Later, the QK scheduler uses this pointer for extended context switch and passes the pointer to the macro <a class="el" href="qk__port_8h.html#a0fff98f5737d46ce7a2228e38486c5ba" title="Define the method for switching the Thread-Local-Storage for for a given thread.">QK_TLS</a>. </p>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00080">80</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7076e6697a723fef583044ca5c2efde2"></a><!-- doxytag: member="qk.h::QK_SCHEDULE_" ref="a7076e6697a723fef583044ca5c2efde2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QK_SCHEDULE_</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;QK_schedule_(intLockKey_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an internal macro for invoking QK scheduler with interrupts locked. </p>
<p>The purpose of this macro is to enable writing the same code for the case when interrupt key is defined and when it is not. If the macro QF_INT_KEY_TYPE is defined, this internal macro invokes <a class="el" href="qk_8h.html#a7cebcd790e3028f59e577238cfb71af2" title="The QK scheduler.">QK_schedule_()</a> passing the key variable as the parameter. Otherwise <a class="el" href="qk_8h.html#a7cebcd790e3028f59e577238cfb71af2" title="The QK scheduler.">QK_schedule_()</a> is invoked without parameters. </p>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00331">331</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00076">QF_run()</a>, and <a class="el" href="qk__mutex_8c_source.html#l00066">QK_mutexUnlock()</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a13b8c3b1b8a65b6e521505922f643104"></a><!-- doxytag: member="qk.h::QMutex" ref="a13b8c3b1b8a65b6e521505922f643104" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK Mutex type. </p>
<p>QMutex represents the priority-ceiling mutex available in QK. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> </dd>
<dd>
<a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00253">253</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1c0552f5268496a3fba67424fe9accb0"></a><!-- doxytag: member="qk.h::QK_getPortVersion" ref="a1c0552f5268496a3fba67424fe9accb0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const Q_ROM* Q_ROM_VAR QK_getPortVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the QK-port version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the QK-port version string is "1.1.03".</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#adb582ced35db744615453884461a03e0" title="get the current QK version number string">QK_getVersion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb582ced35db744615453884461a03e0"></a><!-- doxytag: member="qk.h::QK_getVersion" ref="adb582ced35db744615453884461a03e0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const Q_ROM* Q_ROM_VAR QK_getVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the current QK version number string </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>version of the QK as a constant 6-character string of the form x.y.zz, where x is a 1-digit major version number, y is a 1-digit minor version number, and zz is a 2-digit release number.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#a1c0552f5268496a3fba67424fe9accb0" title="Returns the QK-port version.">QK_getPortVersion()</a> </dd></dl>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00054">54</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00063">Q_ROM</a>, <a class="el" href="qevent_8h_source.html#l00081">Q_ROM_VAR</a>, and <a class="el" href="qevent_8h_source.html#l00047">QP_VERSION</a>.</p>

</div>
</div>
<a class="anchor" id="ae1fa4705c311e29699a0164a20362bf1"></a><!-- doxytag: member="qk.h::QK_init" ref="ae1fa4705c311e29699a0164a20362bf1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK initialization. </p>
<p><a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1" title="QK initialization.">QK_init()</a> is called from <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> in <a class="el" href="qk_8c.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK_getVersion(), QF_init(), QF_run(), QF_stop(), QActive_start(), QActive_stop() implementations.">qk.c</a>. This function is defined in the QK ports. </p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00067">QF_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a02a27011a5aa955b140cd749b64b16e2"></a><!-- doxytag: member="qk.h::QK_mutexLock" ref="a02a27011a5aa955b140cd749b64b16e2" args="(uint8_t prioCeiling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a> QK_mutexLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>prioCeiling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK priority-ceiling mutex lock. </p>
<p>Lock the QK scheduler up to the priority level <em>prioCeiling</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be always paired with <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a>. The code between <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> and <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> should be kept to the minimum.</dd></dl>
<div class="fragment"><pre class="fragment">    <a class="code" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104" title="QK Mutex type.">QMutex</a> mux;
    . . .
    mux = <a class="code" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock</a>(PRIO_CEILING);

    <span class="comment">/* access the shared resource */</span>

    <a class="code" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock</a>(mux);

    . . . 
</pre></div> 
<p>Definition at line <a class="el" href="qk__mutex_8c_source.html#l00047">47</a> of file <a class="el" href="qk__mutex_8c_source.html">qk_mutex.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qk__pkg_8h_source.html#l00065">QK_INT_LOCK_</a>, <a class="el" href="qk__pkg_8h_source.html#l00054">QK_INT_LOCK_KEY_</a>, <a class="el" href="qk__pkg_8h_source.html#l00076">QK_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00728">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00740">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00108">QS_QK_MUTEX_LOCK</a>, and <a class="el" href="qs_8h_source.html#l00745">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4ddf313bcfd3cac43225f2a35e278a"></a><!-- doxytag: member="qk.h::QK_mutexUnlock" ref="a9f4ddf313bcfd3cac43225f2a35e278a" args="(QMutex mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_mutexUnlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK priority-ceiling mutex unlock. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be always paired with <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a>. The code between <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> and <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> should be kept to the minimum.</dd></dl>
<div class="fragment"><pre class="fragment">    <a class="code" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104" title="QK Mutex type.">QMutex</a> mux;
    . . .
    mux = <a class="code" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock</a>(PRIO_CEILING);

    <span class="comment">/* access the shared resource */</span>

    <a class="code" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock</a>(mux);

    . . . 
</pre></div> 
<p>Definition at line <a class="el" href="qk__mutex_8c_source.html#l00066">66</a> of file <a class="el" href="qk__mutex_8c_source.html">qk_mutex.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qk__pkg_8h_source.html#l00065">QK_INT_LOCK_</a>, <a class="el" href="qk__pkg_8h_source.html#l00054">QK_INT_LOCK_KEY_</a>, <a class="el" href="qk__pkg_8h_source.html#l00076">QK_INT_UNLOCK_</a>, <a class="el" href="qk_8h_source.html#l00331">QK_SCHEDULE_</a>, <a class="el" href="qs_8h_source.html#l00728">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00740">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00109">QS_QK_MUTEX_UNLOCK</a>, and <a class="el" href="qs_8h_source.html#l00745">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a667daad24b172e782fe4e2b5b06fbf61"></a><!-- doxytag: member="qk.h::QK_onIdle" ref="a667daad24b172e782fe4e2b5b06fbf61" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_onIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK idle callback (customized in BSPs for QK) </p>
<p><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a> is called continously by the QK idle loop. This callback gives the application an opportunity to enter a power-saving CPU mode, or perform some other idle processing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a> is invoked with interrupts unlocked and must also return with interrupts unlocked.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a47f47f7a1778d20b7ee414183e90d001" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a> </dd></dl>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00076">QF_run()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cebcd790e3028f59e577238cfb71af2"></a><!-- doxytag: member="qk.h::QK_schedule_" ref="a7cebcd790e3028f59e577238cfb71af2" args="(QF_INT_KEY_TYPE intLockKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_schedule_ </td>
          <td>(</td>
          <td class="paramtype">QF_INT_KEY_TYPE&#160;</td>
          <td class="paramname"><em>intLockKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The QK scheduler. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The QK scheduler must be always called with the interrupts locked and unlocks interrupts internally.</dd></dl>
<p>The signature of <a class="el" href="qk_8h.html#a7cebcd790e3028f59e577238cfb71af2" title="The QK scheduler.">QK_schedule_()</a> depends on the policy of locking and unlocking interrupts. When the interrupt lock key is not used (QF_INT_KEY_TYPE undefined), the signature is as follows: <br/>
 void QK_schedule_(void); <br/>
</p>
<p>However, when the interrupt key lock is used (QF_INT_KEY_TYPE defined), the signature is different: <br/>
 void <a class="el" href="qk__sched_8c.html#adfc30aa55411fad638108f9ed73ecdf4" title="The QK scheduler.">QK_schedule_(QF_INT_KEY_TYPE intLockKey)</a>; <br/>
</p>
<p>For the internal use, these differences are hidden by the macro <a class="el" href="qk_8h.html#a7076e6697a723fef583044ca5c2efde2" title="This is an internal macro for invoking QK scheduler with interrupts locked.">QK_SCHEDULE_()</a>. </p>

<p>Definition at line <a class="el" href="qk__sched_8c_source.html#l00044">44</a> of file <a class="el" href="qk__sched_8c_source.html">qk_sched.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>, <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf_8h_source.html#l00109">QF_ACTIVE_DISPATCH_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qk_8c_source.html#l00048">QK_currPrio_</a>, <a class="el" href="qk__pkg_8h_source.html#l00065">QK_INT_LOCK_</a>, <a class="el" href="qk__pkg_8h_source.html#l00076">QK_INT_UNLOCK_</a>, <a class="el" href="qk_8c_source.html#l00049">QK_intNest_</a>, <a class="el" href="qk_8c_source.html#l00045">QK_readySet_</a>, <a class="el" href="qk__port_8h_source.html#l00082">QK_TLS</a>, <a class="el" href="qpset_8h_source.html#l00160">QPSet64_findMax</a>, <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00728">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00740">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00110">QS_QK_SCHEDULE</a>, <a class="el" href="qs_8h_source.html#l00745">QS_U8_</a>, and <a class="el" href="qf_8h_source.html#l00144">QActive::super</a>.</p>

</div>
</div>
<a class="anchor" id="a43706de173a29dc03950d3647eb41eb4"></a><!-- doxytag: member="qk.h::QK_scheduleExt_" ref="a43706de173a29dc03950d3647eb41eb4" args="(QF_INT_KEY_TYPE intLockKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_scheduleExt_ </td>
          <td>(</td>
          <td class="paramtype">QF_INT_KEY_TYPE&#160;</td>
          <td class="paramname"><em>intLockKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The QK extended scheduler for interrupt context. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The QK extended exscheduler must be always called with the interrupts locked and unlocks interrupts internally.</dd></dl>
<p>The signature of <a class="el" href="qk_8h.html#a43706de173a29dc03950d3647eb41eb4" title="The QK extended scheduler for interrupt context.">QK_scheduleExt_()</a> depends on the policy of locking and unlocking interrupts. When the interrupt lock key is not used (QF_INT_KEY_TYPE undefined), the signature is as follows: <br/>
 void QK_scheduleExt_(void); <br/>
</p>
<p>However, when the interrupt key lock is used (QF_INT_KEY_TYPE defined), the signature is different: <br/>
 void <a class="el" href="qk__ext_8c.html#a9a97f5b77e3b31311430a709f147c386" title="The QK extended scheduler for interrupt context.">QK_scheduleExt_(QF_INT_KEY_TYPE intLockKey)</a>; <br/>
 </p>

<p>Definition at line <a class="el" href="qk__ext_8c_source.html#l00044">44</a> of file <a class="el" href="qk__ext_8c_source.html">qk_ext.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>, <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf_8h_source.html#l00109">QF_ACTIVE_DISPATCH_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qk_8c_source.html#l00048">QK_currPrio_</a>, <a class="el" href="qk__port_8h_source.html#l00061">QK_EXT_RESTORE</a>, <a class="el" href="qk__port_8h_source.html#l00051">QK_EXT_SAVE</a>, <a class="el" href="qk__pkg_8h_source.html#l00065">QK_INT_LOCK_</a>, <a class="el" href="qk__pkg_8h_source.html#l00076">QK_INT_UNLOCK_</a>, <a class="el" href="qk_8c_source.html#l00049">QK_intNest_</a>, <a class="el" href="qk_8c_source.html#l00045">QK_readySet_</a>, <a class="el" href="qk__port_8h_source.html#l00082">QK_TLS</a>, <a class="el" href="qpset_8h_source.html#l00160">QPSet64_findMax</a>, <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00728">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00740">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00110">QS_QK_SCHEDULE</a>, <a class="el" href="qs_8h_source.html#l00745">QS_U8_</a>, and <a class="el" href="qf_8h_source.html#l00144">QActive::super</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a81b2832f194ed3d09803c8a4e86a1a23"></a><!-- doxytag: member="qk.h::QK_currPrio_" ref="a81b2832f194ed3d09803c8a4e86a1a23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> volatile <a class="el" href="qk_8c.html#a81b2832f194ed3d09803c8a4e86a1a23">QK_currPrio_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>current task/interrupt priority </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00048">48</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>Referenced by <a class="el" href="qk__sched_8c_source.html#l00044">QK_schedule_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00044">QK_scheduleExt_()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c90cb8ede2a3fa89616f23b7df258de"></a><!-- doxytag: member="qk.h::QK_intNest_" ref="a2c90cb8ede2a3fa89616f23b7df258de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> volatile <a class="el" href="qk_8c.html#a2c90cb8ede2a3fa89616f23b7df258de">QK_intNest_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>interrupt nesting level </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00049">49</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>Referenced by <a class="el" href="qk__sched_8c_source.html#l00044">QK_schedule_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00044">QK_scheduleExt_()</a>.</p>

</div>
</div>
<a class="anchor" id="aa76ad1523d8a245329aa8505ee3fe778"></a><!-- doxytag: member="qk.h::QK_readySet_" ref="aa76ad1523d8a245329aa8505ee3fe778" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_p_set64.html">QPSet64</a> volatile <a class="el" href="qk_8c.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>QK ready-set </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00045">45</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>Referenced by <a class="el" href="qk__sched_8c_source.html#l00044">QK_schedule_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00044">QK_scheduleExt_()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Sep 23 2011 14:24:41 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
